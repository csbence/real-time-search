#!/usr/bin/python3

# generatePlots.py
# This is a script for generating plots for data generated by the real time 
# search project.  The input is any number of result files in JSON format.  The 
# configuration entries will be read and the algorithms and domains will be 
# automatically separated.

import getopt
import json
import matplotlib.pyplot as plt
import numpy as np
import os
import sys

import plotutils

script = os.path.basename(sys.argv[0])
options = "hs:q"


def usage():
    print("usage:")
    print("{} [{}] file1 file2 ...").format(script, options)
    print("options:")
    print("  h         print(this usage info")
    print("  s<file>   save to file")
    print("  q         quiet mode; no logging or graph showing")


save_file = None
quiet = False

try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], options)
except getopt.GetoptError:
    usage()
    sys.exit(2)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage()
        sys.exit(0)
    elif opt in ('-s', '--save'):
        save_file = arg
    elif opt in ('-q', '--quiet'):
        quiet = True
    else:
        print("invalid switch " + opt)
        usage()
        sys.exit(2)

# Process files from command line
num_files = len(args)
if len(args) == 0:
    print("ERROR: No files provided")
    usage()
    sys.exit(2)

times = {}
domain_counts = {}
algorithm_counts = {}
num_domains = 0
num_algorithms = 0
for json_file in args:
    if os.path.exists(json_file):
        f = open(json_file, 'r')
        if not quiet:
            print("File: " + json_file)
        parsedJson = json.loads(f.read())

        if parsedJson['success']:
            results = plotutils.Results(parsedJson)
            if results.configuration not in times:
                times[results.configuration] = []
            times[results.configuration].append(results.time)

            # Checking for common domain
            if results.configuration[plotutils.Results.DOMAIN] not in domain_counts:
                domain_counts[results.configuration[plotutils.Results.DOMAIN]] = 0
                num_domains += 1
            else:
                domain_counts[results.configuration[plotutils.Results.DOMAIN]] += 1

            # Checking for common algorithms
            if results.configuration[plotutils.Results.ALGORITHM] not in algorithm_counts:
                algorithm_counts[results.configuration[plotutils.Results.ALGORITHM]] = 0
                num_algorithms += 1
            else:
                algorithm_counts[results.configuration[plotutils.Results.ALGORITHM]] += 1

            if not quiet:
                print("== Configuration ==")
                print("Algorithm: ".format(results.configuration[plotutils.Results.ALGORITHM]))
                print("Domain: ".format(results.configuration[plotutils.Results.DOMAIN]))

                print("== Results ==")
                print("Generated Nodes: ".format(results.generatedNodes))
                print("Expanded Nodes: ".format(results.expandedNodes))
                print("Path length: ".format(len(results.actions)))
                print("Time (ns): ".format(results.time))

                print()
        elif not quiet:
            print("Failure:".format(parsedJson['errorMessage']))
    else:
        if not quiet:
            print("Skipping non-existent file '%s'" % json_file)

# TODO cleanup and pop code duplication
domain_groups = True
if num_domains != 1:
    if num_algorithms < num_domains:
        print("Data grouped by algorithm, not by domain...")
        domain_groups = False
        if num_algorithms != 1:
            print("Removing extra algorithms...")
            # Get max algorithm count
            max_algorithm = None
            max_count = 0
            for key, value in algorithm_counts.items():
                if value > max_count:
                    max_count = value
                    max_algorithm = key
            # Remove data from other algorithms
            for key, value in times.items():
                if key.algorithm != max_algorithm:
                    del times[key]
                    num_algorithms -= 1
    else:
        print("Removing extra domains...")
        # Get max domain count
        max_domain = None
        max_count = 0
        for key, value in domain_counts.items():
            if value > max_count:
                max_count = value
                max_domain = key
        # Remove data from other domains
        for key, value in times.items():
            if key[plotutils.Results.DOMAIN] != max_domain:
                del times[key]
                num_domains -= 1

# print(times
# data = np.concatenate(times.values())
data = times.values()
# print(data
# datadata = np.array(data)

# print(data
# print(datadata
# print(datadata.reshape(len(data[0]), len(data))

plt.ylabel("Goal Achievement Time (ms)")
labels = []
if domain_groups:
    assert num_domains == 1
    plt.xlabel("Algorithm")
    plt.title(plotutils.translate_domain_name(next(iter(domain_counts.keys()))))
    for key in times.keys():  # Assumes same order will be plotted
        labels.append(plotutils.translate_algorithm_name(key[plotutils.Results.ALGORITHM]))
else:
    assert num_algorithms == 1
    plt.xlabel("Domain")
    plt.title(plotutils.translate_algorithm_name(algorithm_counts.keys()[0]))
    for key in times.keys():
        labels.append(plotutils.translate_domain_name(key[plotutils.Results.DOMAIN]))

# print(len(data)
x = np.arange(1, len(times) + 1)
y = data
print(x)
print(y)

med, confidence_intervals_low, confidence_intervals_high = plotutils.median_confidence_intervals(y)

# plt.rcParams.update({'font.size': 14})
plt.boxplot(y, notch=False, labels=labels, boxprops=dict(linewidth=2))
plt.errorbar(x, med, yerr=(confidence_intervals_low, confidence_intervals_high), fmt='none', linewidth=3)
plt.ylim([min(min(y)) - 1, max(max(y)) + 1])


# Save before showing since show resets the figures
if save_file is not None:
    plotutils.save_plot(plt, save_file)

if not quiet:
    print("Plotting...")
    plt.show()
